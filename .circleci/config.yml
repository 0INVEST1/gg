version: 2.1

# Reusable image / compiler definitions
executors:
  gcc7:
    docker:
      - image: gcc:7
        environment:
          CXX: g++
          CC: gcc
          BUILD_FLAGS: -j
          CTEST_FLAGS: -j4 --output-on-failure

  gcc8:
    docker:
      - image: conanio/gcc8
        environment:
          CXX: g++-8
          CC: gcc-8
          BUILD_FLAGS: -j
          CTEST_FLAGS: -j4 --output-on-failure

  gcc9:
    docker:
      - image: conanio/gcc9
        environment:
          CXX: g++-9
          CC: gcc-9
          BUILD_FLAGS: -j
          CTEST_FLAGS: -j4 --output-on-failure

  clang9:
    docker:
      - image: conanio/clang9
        environment:
          CXX: clang++-9
          CC: clang-9
          BUILD_FLAGS: -j
          CTEST_FLAGS: -j4 --output-on-failure

  clang6:
    docker:
      - image: conanio/clang60
        environment:
          CXX: clang++-6.0
          CC: clang-6.0
          BUILD_FLAGS: -j
          CTEST_FLAGS: -j4 --output-on-failure

# Reusable test commands (and initializer for clang 6)
commands:
  install_cmake:
    steps:
      - run: apt-get update -qq
      - run: apt-get install -y cmake

  cmake_prep:
    steps:
      - checkout

  cmake_build:
    steps:
      - cmake_prep
      - run: cmake $CMAKE_FLAGS -DCMAKE_INSTALL_PREFIX:PATH=destination .
      - run: make $BUILD_FLAGS all
      - run: tools/json2json -h # Print out the implementation we're using on this hardware

  cmake_test:
    steps:
      - cmake_build
      - run: ctest $CTEST_FLAGS -L acceptance
      - run: ctest $CTEST_FLAGS -LE acceptance -E checkperf

  cmake_test_all:
    steps:
      - cmake_build
      - run: ctest $CTEST_FLAGS -L acceptance -LE per_implementation
      - run: SIMDJSON_FORCE_IMPLEMENTATION=haswell ctest $CTEST_FLAGS -L per_implementation
      - run: SIMDJSON_FORCE_IMPLEMENTATION=westmere ctest $CTEST_FLAGS -L per_implementation
      - run: SIMDJSON_FORCE_IMPLEMENTATION=fallback ctest $CTEST_FLAGS -L per_implementation
      - run: ctest $CTEST_FLAGS -LE "acceptance|per_implementation" # Everything we haven't run yet, run now.


  # we not only want cmake to build and run tests, but we want also a successful installation from which we can build, link and run programs
  cmake_install_test: # this version builds, install, test and then verify from the installation
    steps:
      - run: make install
      - run: echo -e '#include <simdjson.h>\nint main(int argc,char**argv) {simdjson::dom::parser parser;simdjson::dom::element tweets = parser.load(argv[1]); }' > tmp.cpp && c++ -Idestination/include -Ldestination/lib -std=c++17 -Wl,-rpath,destination/lib -o linkandrun tmp.cpp -lsimdjson && ./linkandrun jsonexamples/twitter.json

jobs:

  # static
  gcc9:
    description: Build and run tests on GCC 7 and AVX 2 with a cmake static build
    executor: gcc9
    environment: { CMAKE_FLAGS: -DSIMDJSON_GOOGLE_BENCHMARKS=ON }
    steps: [ install_cmake, cmake_test_all, cmake_install_test ]
  clang9:
    description: Build and run tests on clang 6 and AVX 2 with a cmake static build
    executor: clang9
    environment: { CMAKE_FLAGS: -DSIMDJSON_GOOGLE_BENCHMARKS=ON }
    steps: [ cmake_test_all, cmake_install_test ]

workflows:
  version: 2.1
  build_and_test:
    jobs:
      # full multi-implementation tests
      - gcc9
      - clang9
